## üèóÔ∏è Architecture

### Single Agent vs Multi-Agent Processing

The MASS system now supports both single-agent and multi-agent scenarios:

**Single Agent Mode:**
- When only one agent is configured, the system automatically detects this and bypasses the full multi-agent orchestration
- Simply calls `process_message` directly on the single agent with the question
- Returns the response immediately without voting, consensus, or debate mechanisms
- Provides faster, simpler processing for straightforward tasks
- Still supports all agent tools and capabilities (search, code execution, etc.)

**Multi-Agent Mode:**
- When multiple agents are configured, the full MASS orchestration system is used
- Agents work asynchronously, share summaries, vote for representatives, and reach consensus through debate

### Multi-Agent Architecture (Multiple Agents)

Each agent works asynchronously. They maintain their own working summary and continuously update it until convergence. Agents can read other agents' working summaries but cannot write to them. They receive notifications when another agent updates their working summary.

Each agent runs its own loop, using available tools to solve the task and sharing/receiving summaries with other agents. They can vote for a representative agent to present the final answer.

### Agent Workflow and Consensus Logic

- **If an agent has voted**: It waits for other agents. However, if any other agent shares a new update, this agent (even though it has voted) will restart, as peer agents may have changed their solution.

- **If all agents have voted but consensus has not been reached**: They enter a debate phase where they restart to continue working, update summaries, or vote again.

- **If all agents have voted and consensus has been reached**: A representative agent is selected. All other agents stop, and the representative agent restarts to present the final answer.

- **Note**: As long as one agent updates its working summary, it can trigger other agents to receive notifications and potentially restart their work, even if they had previously stopped.

- **If maximum rounds are exceeded** (by any agent): The orchestrator system stops the loop, and the agent who received the most votes is selected as representative. In case of a tie, the agent who voted earliest becomes the representative.

The system presents the working process of each agent during the entire session through a multi-region display with streaming features.

## Design Logic

### Agent Backends
Now the codebase support three types of LLM agent backend, include OpenAI, Gemini, Grok.
They have different ways for process_message, and work_on_task.

### Agent Interface
Each agent uses the `MassAgent` interface with minimal complexity designed for LLM-based agents:

### LLM-Callable Tools (provided by system):
- `update_summary()` - Updates working summary and triggers notifications to other agents
- `vote(agent_id)` - Votes for representative agent (can be called multiple times to change vote)

### Core Methods:
- `process_message(message)` - Common async streaming method for all LLM interactions
- `work_on_task(task, restart_instruction=None)` - Works on task (handles both initial work and restarts)
- `present_final_answer(task)` - Presents final answer as representative (uses process_message)

### Orchestrator System MassOrchestrator:
- **Maintains all agent status, system status, and voting information**
- **Handles agent creation, maintains their parallel execution, starts tasks with the MASS system, and runs tasks with agents running in parallel**
- **Logs all information and manages the multi-region display**

Each agent can use any backend (frontier models + tools/MCP, custom implementations) as long as they implement this interface. The system provides complete session state including per-agent status, update counts, and convergence progress.